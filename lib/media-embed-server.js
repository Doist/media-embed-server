// Generated by CoffeeScript 1.10.0
(function() {
  var Memcached, app, async, attachThumbnail, attachTitle, attachType, attachUrl, express, handleAsyncCall, http, media_parser, mime, parse, partial, program, usage, webpage_info;

  http = require('http');

  express = require('express');

  async = require('async');

  program = require('commander');

  partial = require('partial');

  media_parser = require('media-parser');

  webpage_info = require('webpage-info');

  mime = require('mime-types');

  Memcached = require('memcached');

  app = express();

  parse = function(req, res) {
    var _url, callback, cb, cb_functions, content, i, len, min_tn_size, ref, timeout, version;
    version = parseInt(req.query.version || 1);
    timeout = parseInt(req.query.timeout || 5) * 1000;
    content = req.query.content || "";
    min_tn_size = parseInt(req.query.min_tn_size || 100);
    callback = req.query.callback || null;
    cb_functions = [];
    ref = media_parser.allURLs(content);
    for (i = 0, len = ref.length; i < len; i++) {
      _url = ref[i];
      cb = function(url, async_cb) {
        var cache_key;
        cache_key = _url + ':' + min_tn_size;
        return app.cache.get(cache_key, function(err, cached_data) {
          var e, error;
          if (cached_data) {
            try {
              cached_data = JSON.parse(cached_data);
            } catch (error) {
              e = error;
              cached_data = null;
            }
          }
          if (cached_data) {
            return async_cb(null, cached_data);
          } else {
            return media_parser.parse(url, function(parsed_obj) {
              var result, thumb_info, update_cache;
              if (parsed_obj) {
                result = {};
                if (parsed_obj.underlying_type) {
                  result.type = parsed_obj.underlying_type;
                } else {
                  attachType(version, result, url);
                }
                attachTitle(version, result, parsed_obj.title, url);
                attachUrl(version, result, url);
                if (parsed_obj.raw && parsed_obj.raw.html) {
                  result.html = parsed_obj.raw.html;
                }
                if (parsed_obj.content_url && parsed_obj.content_type) {
                  result.content_url = parsed_obj.content_url;
                  result.content_type = parsed_obj.content_type;
                }
                if (parsed_obj.get_thumbnail_url) {
                  thumb_info = parsed_obj.get_thumbnail_url(min_tn_size);
                  if (thumb_info) {
                    attachThumbnail(version, result, thumb_info);
                  }
                }
                update_cache = true;
                return handleAsyncCall(async_cb, cache_key, update_cache, result, timeout, version);
              } else {
                return webpage_info.parse(url, function(parsed_obj) {
                  if (parsed_obj.error || !parsed_obj.title) {
                    result = {
                      'error': 'Could not resolve resource'
                    };
                    update_cache = false;
                  } else {
                    result = {};
                    update_cache = true;
                    attachType(version, result, url);
                    attachTitle(version, result, parsed_obj.title, url);
                    if (parsed_obj.thumbnail) {
                      result.thumbnail = parsed_obj.thumbnail;
                    }
                  }
                  attachUrl(version, result, url);
                  return handleAsyncCall(async_cb, cache_key, update_cache, result, timeout, version);
                });
              }
            }, timeout);
          }
        });
      };
      cb_functions.push(partial(cb, _url));
    }
    return async.parallel(cb_functions, function(err, cb_results) {
      var json;
      json = JSON.stringify(cb_results);
      if (callback) {
        res.set({
          'Content-Type': 'text/javascript; charset=utf-8'
        });
        return res.send(callback + "(" + json.toString('utf8') + ")");
      } else {
        res.set({
          'Content-Type': 'application/json; charset=utf-8'
        });
        return res.send(json.toString('utf8'));
      }
    });
  };

  handleAsyncCall = function(async_cb, cache_key, update_cache, result, timeout, version) {
    var callback, thumbnail;
    callback = function() {
      if (update_cache) {
        app.cache.set(cache_key, JSON.stringify(result), 3600 * 24);
      }
      return async_cb(null, result);
    };
    if (version = 1) {
      thumbnail = result.thumbnail;
      if (thumbnail && thumbnail.width) {
        thumbnail.width = parseInt(thumbnail.width);
      }
      if (thumbnail && thumbnail.height) {
        thumbnail.height = parseInt(thumbnail.height);
      }
    }
    return callback();
  };

  app.get('/parseContent', function(req, res) {
    req.query.version = 2;
    return parse(req, res);
  });

  app.get('/parse', parse);

  attachTitle = function(version, result, title, url) {
    if (title && title.length > 0) {
      return result.title = title;
    } else {
      return result.title = url;
    }
  };

  attachUrl = function(version, result, url) {
    if (version === 1) {
      return result.matched_url = url;
    } else {
      return result.url = url;
    }
  };

  attachType = function(version, result, url) {
    return result.type = mime.lookup(url) || 'text/html';
  };

  attachThumbnail = function(version, result, thumb_info) {
    if (version === 1) {
      result.thumbnail_url = thumb_info[0];
      result.thumbnail_width = thumb_info[1];
      return result.thumbnail_height = thumb_info[2];
    } else {
      return result.thumbnail = thumb_info[0];
    }
  };

  app.get('/providers', function(req, res) {
    res.set({
      'Content-Type': 'application/json'
    });
    return res.send(media_parser.getProviders());
  });

  process.on('uncaughtException', function(err) {
    return console.log(err);
  });

  usage = "A specialized API for handling oemebed requests";

  program.version('2.0.0').usage(usage).option('-p, --port <port>').option('-c, --cache <cache>').parse(process.argv);

  program.port = parseInt(program.port || '8080');

  program.cache = program.cache || null;

  if (program.cache) {
    app.cache = new Memcached(program.cache, {
      'timeout': 500,
      'failures': 1
    });
  } else {
    app.cache = {
      get: function(key, cb) {
        return cb();
      },
      set: function() {
        return null;
      }
    };
  }

  app.listen(program.port);

  console.log('Started Media Server on ' + program.port);

}).call(this);
