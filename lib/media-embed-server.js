// Generated by CoffeeScript 1.7.1
(function() {
  var Memcached, app, async, express, media_parser, partial, program, usage, webpage_info;

  express = require('express');

  async = require('async');

  program = require('commander');

  partial = require('partial');

  media_parser = require('media-parser');

  webpage_info = require('webpage-info');

  Memcached = require('memcached');

  app = express();

  app.unknown_error = {
    'error': 'Could not resolve resource'
  };

  app.get('/parse', function(req, res) {
    var callback, cb, cb_functions, content, min_tn_size, timeout, _i, _len, _ref, _url;
    timeout = parseInt(req.query.timeout || 5) * 1000;
    content = req.query.content || "";
    min_tn_size = parseInt(req.query.min_tn_size || 100);
    callback = req.query.callback || null;
    cb_functions = [];
    _ref = media_parser.allURLs(content);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _url = _ref[_i];
      cb = function(url, async_cb) {
        var cache_key;
        cache_key = _url + ':' + min_tn_size;
        return app.cache.get(cache_key, function(err, cached_data) {
          var e;
          if (cached_data) {
            try {
              cached_data = JSON.parse(cached_data);
            } catch (_error) {
              e = _error;
              cached_data = null;
            }
          }
          if (cached_data) {
            return async_cb(null, cached_data);
          } else {
            return media_parser.parse(url, function(obj) {
              var thumb_info;
              if (obj) {
                if (obj.get_thumbnail_url) {
                  thumb_info = obj.get_thumbnail_url(min_tn_size);
                  delete obj.get_thumbnail_url;
                  if (thumb_info) {
                    obj.thumbnail_url = thumb_info[0];
                    obj.thumbnail_width = thumb_info[1];
                    obj.thumbnail_height = thumb_info[2];
                  }
                }
                obj.matched_url = url;
                app.cache.set(cache_key, JSON.stringify(obj), 3600);
                return async_cb(null, obj);
              } else {
                return webpage_info.parse(url, function(page_info) {
                  var result;
                  if (page_info.error) {
                    result = app.unknown_error;
                    result.matched_url = url;
                  } else {
                    result = page_info;
                    result.matched_url = url;
                    app.cache.set(cache_key, JSON.stringify(result), 3600);
                  }
                  return async_cb(null, result);
                });
              }
            }, timeout);
          }
        });
      };
      cb_functions.push(partial(cb, _url));
    }
    return async.parallel(cb_functions, function(err, cb_results) {
      var json;
      json = JSON.stringify(cb_results);
      if (callback) {
        res.set({
          'Content-Type': 'text/javascript'
        });
        return res.send(callback + "(" + json + ")");
      } else {
        res.set({
          'Content-Type': 'application/json'
        });
        return res.send(json);
      }
    });
  });

  app.get('/providers', function(req, res) {
    res.set({
      'Content-Type': 'application/json'
    });
    return res.send(media_parser.getProviders());
  });

  usage = "A specialized API for handling oemebed requests";

  program.version('0.0.1').usage(usage).option('-p, --port <port>').option('-c, --cache <cache>').parse(process.argv);

  program.port = parseInt(program.port || '8080');

  program.cache = program.cache || null;

  if (program.cache) {
    app.cache = new Memcached(program.cache, {
      'timeout': 500,
      'failures': 1
    });
  } else {
    app.cache = {
      get: function(key, cb) {
        return cb();
      },
      set: function() {
        return null;
      }
    };
  }

  app.listen(program.port);

  console.log('Started Media Server on ' + program.port);

}).call(this);
